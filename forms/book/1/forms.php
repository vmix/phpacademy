<?php
/**
 * Created by PhpStorm.
 * User: 0311
 * Date: 04.05.2017
 * Time: 1:47 PM
 */
/**
 * HTTP относится к категории протоколов без состояния — в нем нет встроенного
механизма, позволяющего сохранить информацию с одной страницы, чтобы об-
ратиться к ней из других страниц.
 * При обработке страницы PHP проверяет URL-адрес и переменные формы, от-
правленные файлы, действующие cookie, переменные веб-сервера и окружения.
Полученные данные напрямую доступны в следующих массивах: $_GET, $_POST,
$_FILES, $_COOKIE, $_SERVER и $_ENV. В них хранятся соответственно все перемен-
ные, заданные в строке запроса, в теле запроса, отправкой файлов, cookie, веб-
сервером и окружением, в котором работает веб-сервер. Также существует
$_REQUEST — один большой массив, в котором содержатся значения из шести
массивов.
 * При размещении элементов в $_REQUEST, если два массива содержат одноименные
ключи, PHP разрешает конфликт в соответствии с конфигурационной директи-
вой variables_order. По умолчанию variables_order использует порядок EGPCS
(или GPCS, если вы используете конфигурационный файл php.ini-recommended).
Итак, PHP сначала добавляет в $_REQUEST переменные окружения, а затем до-
бавляет в массив переменные строки запроса, отправленные значения, данные
cookie и переменные веб-сервера в указанном порядке. Например, так как C в по-
рядке по умолчанию следует после P, cookie с именем username заменяет отправ-
ленную переменную с именем username. Следует заметить, что со значением GPCS
из файла php.ini-recommended массив $_ENV не заполняется переменными окруже-
ния.
 * Хотя массив $_REQUEST может быть удобен, обычно удобнее работать со специали-
зированными массивами. В этом случае вы точно знаете, что получаете, и вам не
нужно беспокоиться о том, что изменение variables_order повлияет на поведение
программы.
 * Все эти массивы являются автоглобальными. Этот термин обозначает глобаль-
ность внутри функции или класса — они всегда находятся в области видимости.
В версиях PHP до 5.4.0 поддерживалась конфигурационная директива с именем
register_globals. Если она была установлена, то все эти переменные также ста-
новились доступны в виде переменных глобального пространства имен. Итак,
значение $_GET['password'] также доступно под именем $password. При всем
удобстве такой подход создает серьезные проблемы с безопасностью, потому что
злоумышленник может легко задать переменные снаружи и заменить доверенные
внутренние переменные. Если вы используете старую версию PHP, проследите
за тем, чтобы эта директива была отключена.
 */
