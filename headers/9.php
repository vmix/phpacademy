<?php
/**
 * Created by PhpStorm.
 * User: Ivan
 * Date: 5/17/17
 * Time: 12:10 PM
 * Чтение заголовка HTTP
 */
// Заголовок User-Agent
echo $_SERVER['HTTP_USER_AGENT'];

#Для получения всех заголовков вызовите функцию getallheaders():
$headers = getallheaders();
echo $headers['User-Agent'];

/**
 * Заголовки HTTP позволяют браузеру (или любому приложению) передать до-
полнительную информацию о запросе. Например, заголовок Content-Type опи-
сывает тело запроса (что было отправлено — веб-форма или данные JSON),
Accept-Language содержит список предпочтительных языков (канадский англий-
ский или канадский французский?), а User-Agent определяет пользовательского
агента (имя и описание браузера).
Иногда веб-сервер автоматически обрабатывает заголовки и действует соответ-
ствующим образом, особенно в том, что касается низкоуровневых подробностей
запроса (например, предоставления данных из кэша или сжатия данных). В дру-
гих случаях PHP разбирает нужные заголовки по мере надобности, как показано
в Рецептах 8.2 и 8.6.
Но встречаются ситуации, в которых требуется прочитать конкретный заголовок
из программного кода. Один из примеров — разбор заголовка ETag для проверки
версии ресурса.
В таких случаях следует работать с суперглобальным массивом $_SERVER. PHP
выделяет заголовки запросов HTTP в отдельное пространство имен, снабжая имя
заголовка префиксом HTTP_. Кроме того, все имена заголовков переводятся в верх-
ний регистр, чтобы упростить их нахождение. (Это нормально, потому что регистр
символов в именах заголовков игнорируется.)
Итак, для заголовка ETag, если он отправлен, будет храниться в элементе
$_SERVER['HTTP_ETAG']. Если модификация имен полей кажется вам эстетически
неприемлемой, данные также можно получить вызовом getallheaders()['Etag'].
 */